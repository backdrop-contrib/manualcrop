<?php
/**
 * @file
 * Exposes functionality for manually cropping an image.
 */

require_once 'manualcrop.effects.inc';
require_once 'manualcrop.widget.inc';

/**
 * Implements hook_help().
 */
function manualcrop_help($path) {
  switch ($path) {
    case 'admin/config/media/image-styles/edit/%':
      return '<p>' . t("<strong>Note:</strong> if you are using a manual crop effect, it's forced to be the only manual crop effect and first effect in the list.") . '</p>';
  }
}

/**
 * Implements hook_theme().
 */
function manualcrop_theme() {
  return array(
    'manualcrop_crop_and_scale_summary' => array(
      'variables' => array('data' => NULL),
    ),
    'manualcrop_crop_summary' => array(
      'variables' => array('data' => NULL),
    ),
    'manualcrop_overlay' => array(
      'variables' => array('fid' => NULL, 'path' => NULL),
    ),
    'manualcrop_widget' => array(
      'render element' => 'element',
    ),
  );
}

/**
 * Form Builder; Configuration settings for manual crop and scale effect.
 *
 * @param $data
 *   The current configuration for this manual crop and scale effect.
 */
function manualcrop_crop_and_scale_form($data) {
  $form = image_scale_form($data);

  $form['width']['#required'] = TRUE;
  $form['height']['#required'] = TRUE;

  $form['respectminimum'] = array(
    '#type' => 'checkbox',
    '#title' => t('Respect minimum'),
    '#description' => t("Make sure the selected crop area is at least as big as the destination size. This doesn't enforce minimum image dimensions."),
    '#default_value' => (isset($data['respectminimum'])) ? $data['respectminimum'] : 0,
  );

  return $form;
}

/**
 * Returns HTML for a summary of an image manual crop and scale effect.
 *
 * @param $variables
 *   An associative array containing:
 *   - data: The current configuration for this manual crop and scale effect.
 *
 * @ingroup themeable
 */
function theme_manualcrop_crop_and_scale_summary($variables) {
  $data = $variables["data"];
  $str = check_plain($data['width']) . 'x' . check_plain($data['height']);

  if ($data['upscale'] || $data['respectminimum']) {
    $str .= ' (' . ($data['upscale'] ? t('upscaling allowed') : '');
    $str .= ($data['upscale'] && $data['respectminimum'] ? ' ' . t('and') . ' ' : '');
    $str .= ($data['respectminimum'] ? t('crop minimum dimensions') : '') . ')';
  }

  return $str;
}

/**
 * Form Builder; Configuration settings for manual crop effect.
 *
 * @param $data
 *   The current configuration for this manual crop effect.
 */
function manualcrop_crop_form($data) {
  $form = image_resize_form($data);

  $form['width']['#title'] = t('Minimum crop width');
  $form['width']['#description'] = t("Only applied if a user tries to crop, this enforces no minimum image width!");
  $form['width']['#required'] = FALSE;

  $form['height']['#title'] = t('Minimum crop height');
  $form['height']['#description'] = t("Only applied if a user tries to crop, this enforces no minimum image height!");
  $form['height']['#required'] = FALSE;

  return $form;
}

/**
 * Returns HTML for a summary of an image resize effect.
 *
 * @param $variables
 *   An associative array containing:
 *   - data: The current configuration for this resize effect.
 *
 * @ingroup themeable
 */
function theme_manualcrop_crop_summary($variables) {
  $data = $variables['data'];

  if ($data['width'] && $data['height']) {
    return ' (' . t('minimum crop dimensions ') . ' ' . check_plain($data['width']) . 'x' . check_plain($data['height']) . ')';
  }
  elseif ($data['width'] || $data['height']) {
    return ' (' . ($data['width']) ? t('minimum crop width @width', array('@width' => $data['width'])) : t('minimum crop height @height', array('@height' => $data['height'])) . ')';
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function manualcrop_form_image_effect_form_alter(&$form, &$form_state) {
  if (!is_array($form['#submit'])) {
    $form['#submit'] = array('image_effect_form_submit');
  }

  // If it's a manual crop effect do a custom submit handler first.
  // Otherwise reorder the effects after the submit.
  if ($form_state['image_effect']['module'] == 'manualcrop') {
    array_unshift($form['#submit'], 'manualcrop_image_effect_form_submit');
  }
  elseif (!empty($form_state['image_style']['effects'])) {
    $form['#submit'][] = 'manualcrop_force_effect_order';
  }
}

/**
 * Effect form submit handler; Sets the image style name and weight of the effect.
 *
 * @param $form
 *   Effect form array.
 * @param $form_state
 *   Form state array.
 */
function manualcrop_image_effect_form_submit($form, &$form_state) {
  $style = $form_state['image_style'];
  $effect = $form_state['image_effect'];

  // Set style name so the effect can use it.
  $form_state['values']['data']['style_name'] = $style['name'];

  if (count($style['effects']) == 0) {
    // First effect, so weight is 0.
    $form_state['values']['weight'] = 0;
  }
  elseif (!isset($effect['ieid'])) {
    // New effect, weight must be the weight of the first one minus 1.
    $first = reset($style['effects']);
    $form_state['values']['weight'] = $first["weight"] - 1;
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function manualcrop_form_image_effect_delete_form_alter(&$form, &$form_state) {
  if (!is_array($form['#submit'])) {
    $form['#submit'] = array('image_effect_delete_form_submit');
  }

  // If it's a manual crop effect do a custom submit handler to cleanup the cropped areas.
  if ($form_state['image_effect']['module'] == 'manualcrop') {
    array_unshift($form['#submit'], 'manualcrop_image_effect_delete_form_submit');
  }
}

/**
 * Effect deletion form submit handler; Cleanup old selection areas.
 *
 * @param $form
 *   Effect form array.
 * @param $form_state
 *   Form state array.
 */
function manualcrop_image_effect_delete_form_submit($form, &$form_state) {
  manualcrop_image_style_delete($form_state['image_style']);
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function manualcrop_form_image_style_form_alter(&$form, &$form_state) {
  $style = $form_state['image_style'];

  if (!empty($style['effects'])) {
    if (!is_array($form['#submit'])) {
      $form['#submit'] = array('image_style_form_submit');
    }

    // Reorder effects on submit.
    $form['#submit'][] = 'manualcrop_force_effect_order';

    // Update style name in effect data.
    $form['#submit'][] = 'manualcrop_update_style_name';

    // Filter all manual crop effects out of the form if there's already a manual crop effect.
    if (isset($form['effects']['new']['new'])) {
      foreach ($style['effects'] as $effect) {
        if ($effect['module'] == 'manualcrop') {
          $form['effects']['new']['new']['#options'] = array_diff_key($form['effects']['new']['new']['#options'], manualcrop_image_effect_info());
          break;
        }
      }
    }
  }
}

/**
 * Effect and style form submit handler; Force the manual crop effect to be the first one.
 *
 * @param $form
 *   Effect or style form array.
 * @param $form_state
 *   Form state array.
 */
function manualcrop_force_effect_order($form, &$form_state) {
  // In both forms (style and effect) we find the style in the same key.
  $style = $form_state['image_style'];

  // If it's the style form, check if the style name was updated.
  if ($form['#form_id'] == 'image_style_form' && isset($form_state['values']['name']) && $style['name'] != $form_state['values']['name']) {
    $style['name'] = $form_state['values']['name'];
  }

  // The style array is received trough the loader to make sure the function
  // works with the latest version.
  $style = image_style_load($style['name']);

  if (!empty($style['effects'])) {
    foreach ($style['effects'] as $eid => $effect) {
      if ($effect['module'] == 'manualcrop') {
        $first = reset($style['effects']);

        if ($eid != key($style['effects'])) {
          // Change the weight of this effect to the weight of the first effect minus 1.
          $effect['weight'] = $first['weight'] - 1;
          image_effect_save($effect);
        }

        break;
      }
    }
  }
}

/**
 * Style form submit handler; Update the style name in the effect data and in the widgets.
 *
 * @param $form
 *   Style form array.
 * @param $form_state
 *   Form state array.
 */
function manualcrop_update_style_name($form, &$form_state) {
  $style = $form_state['image_style'];

  // Check if the style name should be updated.
  if (!empty($style['effects']) && isset($form_state['values']['name']) && $style['name'] != $form_state['values']['name']) {
    $effect = reset($style['effects']);

    if ($effect['module'] == 'manualcrop') {
      // Change the style name in the effect data and save the effect.
      $effect["data"]["style_name"] = $form_state['values']['name'];
      image_effect_save($effect);

      manualcrop_field_widget_update_names_in_settings($style['name'], $form_state['values']['name']);

      db_update('manualcrop')
        ->fields(array('style_name' => $form_state['values']['name']))
        ->condition('style_name', $style['name'])
        ->execute();
    }
  }
}

/**
 * Implements hook_image_style_delete().
 */
function manualcrop_image_style_delete($style) {
  if (!empty($style['effects'])) {
    $effect = reset($style['effects']);

    if ($effect['module'] == 'manualcrop') {
      db_delete('manualcrop')
        ->condition('style_name', $style['name'])
        ->execute();

      manualcrop_field_widget_update_names_in_settings($style['name']);
    }
  }
}

/**
 * Node form validation handler; Check the cropping selections.
 *
 * @param $form
 *   Node form array.
 * @param $form_state
 *   Form state array.
 */
function manualcrop_validate_crop_selection($form, &$form_state) {
  if (!empty($form_state['manualcrop_widget_data']['images'])) {
    // Create a new key in the data array, this is to store processed selections.
    $form_state['manualcrop_widget_data']['selections'] = array();
    $save = &$form_state['manualcrop_widget_data']['selections'];

    // Loop trough the positions to get the manualcrop data.
    foreach ($form_state['manualcrop_widget_data']['images'] as $image) {
      $value = drupal_array_get_nested_value($form_state['values'], $image['element_parents']);

      if (isset($value['fid']) && isset($value['manualcrop_selection'])) {
        // Create a selections array for the current image, the first element is the path
        // to the original image, needed for flushing the cache.
        $save[$value['fid']] = array(
          'path' => $image['uri'],
          'styles' => array(),
        );

        $first = TRUE;

        foreach ($value['manualcrop_selection'] as $style_name => $selection) {
          if ($first) {
            $element_key = implode('][', $image['element_parents']) . '][manualcrop_style';
          }
          else {
            $element_key = implode('][', $image['element_parents']) . '][manualcrop_selection][' . $style_name;
          }

          if (!empty($selection)) {
            if (preg_match('/^([0-9]+\|){3}[0-9]+$/', $selection)) {
              $selection = array_map('intval', explode('|', $selection));

              // Check position and minimum dimensions.
              if ($selection[0] >= 0 && $selection[1] >= 0 && $selection[2] > 0 && $selection[3] > 0) {
                // Check if the selections fits on the image.
                if (($selection[0] + $selection[2]) <= $image['width'] && ($selection[1] + $selection[3]) <= $image['height']) {
                  $save[$value['fid']]['styles'][$style_name] = array(
                    'x' => $selection[0],
                    'y' => $selection[1],
                    'width' => $selection[2],
                    'height' => $selection[3],
                  );
                  continue;
                }
              }
            }

            form_set_error($element_key, t('The crop selection for %filename (@style image style) is invalid, please clear it or reselect.', array(
              '@style' => $style_name,
              '%filename' => $image['filename']
            )));

            $first = FALSE;
          }
          elseif (in_array($style_name, $image['required_styles'], TRUE)) {
            // Uncropped required style.
            form_set_error($element_key, t('%filename must have a cropping selection for the @style image style.', array(
              '@style' => $style_name,
              '%filename' => $image['filename']
            )));
          }
        }
      }
    }
  }
}

/**
 * Node form submit handler; Save the cropped selection.
 *
 * @param $form
 *   Node form array.
 * @param $form_state
 *   Form state array.
 */
function manualcrop_field_attach_submit($entity_type, $entity, $form, &$form_state) {
  if (!empty($form_state['manualcrop_widget_data']['selections'])) {
    // Loop trough the selections to save them. $styles can by an empty array, but we loop trough
    // the whole array to delete old selections.
    foreach ($form_state['manualcrop_widget_data']['selections'] as $fid => $data) {
      db_delete('manualcrop')
        ->condition('fid', $fid)
        ->execute();

      foreach ($data['styles'] as $style_name => $selection) {
        db_insert('manualcrop')
          ->fields(array_merge($selection, array(
            'fid' => $fid,
            'style_name' => $style_name
          )))
          ->execute();
      }

      // Clear the cached versions of this image.
      image_path_flush($data['path']);

      // Clear the cached image paths.
      cache_clear_all('manualcrop', 'cache', TRUE);
    }
  }
}

/**
 * Implements hook_file_delete().
 */
function manualcrop_file_delete($file) {
  db_delete('manualcrop')->condition('fid', $file->fid)->execute();
}

/**
 * Gets the crop area for an image.
 *
 * @param $file
 *   Path to an image file.
 * @param $style_name
 *   Image style machine name, or empty for all styles.
 * @return
 *   An object defining the cropping area with following items:
 *   - "style_name": The machine name of the image style this cropping area applies on.
 *   - "x": An integer representing the top left corner's x-position in pixels.
 *   - "y": An integer representing the top left corner's y-position in pixels.
 *   - "width": An integer representing the width in pixels.
 *   - "height": An integer representing the height in pixels.
 *   If the style machine name was empty an object with all the styles is returned.
 */
function manualcrop_load_crop_selection($file, $style_name = NULL) {
  if (empty($style_name)) {
    $result = db_query('SELECT c.style_name, c.x, c.y, c.width, c.height FROM {manualcrop} c INNER JOIN {file_managed} f ON c.fid = f.fid WHERE f.uri = :uri', array(
      ':uri' => $file,
    ));

    return $result;
  }
  else {
    $result = db_query('SELECT c.x, c.y, c.width, c.height FROM {manualcrop} c INNER JOIN {file_managed} f ON c.fid = f.fid WHERE c.style_name = :name AND f.uri = :uri', array(
      ':name' => $style_name,
      ':uri' => $file,
    ));

    foreach ($result as $record) {
      return $record;
    }
  }

  return NULL;
}

/**
 * Returns the styles that have crop settings.
 *
 * @return
 *   An array of styles with the style name as key and the effect data as value.
 */
function manualcrop_get_styles_with_crop() {
  $hascrop = &drupal_static(__FUNCTION__, array());

  if (empty($hascrop)) {
    foreach (image_styles() as $style_name => $style) {
      if (!empty($style['effects'])) {
        // Check if the first effect is a manual crop effect.
        $effect = reset($style['effects']);

        if ($effect['module'] == 'manualcrop') {
          $hascrop[$style_name] = $effect;
        }
      }
    }
  }

  return $hascrop;
}

/**
 * Preprocessing for theme_image(); force reloading of an image after re-cropping.
 *
 * @param $variables
 *   Image template variables.
 */
function manualcrop_preprocess_image(&$variables) {
  // Check if this image style has a Manual Crop effect.
  if (isset($variables['style_name']) && array_key_exists($variables['style_name'], manualcrop_get_styles_with_crop())) {
    // Attempt to load HTTP cache-controller from database cache
    $original_path = $variables['path'];

    if ($cached_path = cache_get('manualcrop|' . $original_path)) {
      $variables['path'] = $cached_path->data;
    }
    else {
      // No HTTP cache-controller in database cache, get the image path.
      $match = '/styles/' . $variables['style_name'] . '/';
      $path = substr($variables['path'], (strrpos($variables['path'], $match) + drupal_strlen($match)));
      $path = explode('/', $path);

      // Build the image URI.
      $scheme = array_shift($path);
      $target = implode('/', $path);
      $image_uri = $scheme . '://' . urldecode($target);

      // Load the cropping area.
      if ($crop = manualcrop_load_crop_selection($image_uri, $variables['style_name'])) {
        // Add a HTTP cache-controller to the image path.
        $variables['path'] .= '?c=' . md5($crop->x . '|' . $crop->y . '|' . $crop->width . '|' . $crop->height);

        // Cache the the updated image path.
        cache_set('manualcrop|' . $original_path, $variables['path']);
      }
    }
  }
}

/**
 * Implements hook_filefield_sources_widgets().
 *
 * Integration with the Filefield Sources module.
 *
 * @see http://drupal.org/project/filefield_sources
 */
function manualcrop_filefield_sources_widgets() {
  return array('manualcrop_image');
}